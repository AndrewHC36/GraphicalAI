from __base__ import *  # ~~~ automatically generated by __autoinject__.py ~~~

from typing import List
from PySide6.QtWidgets import *
from PySide6.QtCore import Slot, Signal
from PySide6.QtGui import QFont, QIntValidator, QDoubleValidator

from file_handler import ProjectFileHandler
from model_view.components import AttributeSelector
from model_view.node import FasterNode
from node_graph.loss_funcs import LOSS_FUNCTIONS
from node_state import NodeState
from project import Model
from project.sidemenu_components import ModelIOConfigurator, ConsoleIO, IOField


class TrainingSideMenu(QWidget):
    sg_model_train = Signal()

    def __init__(self, model_name, io_config=None, parent=None):
        super().__init__(parent=parent)

        self.model_name = model_name

        self.wl_mdl_name = QLabel(model_name)
        ql_font: QFont = self.wl_mdl_name.font()
        ql_font.setPointSize(24)
        ql_font.setBold(True)
        self.wl_mdl_name.setFont(ql_font)

        qpb_train = QPushButton("Train")
        qpb_train.pressed.connect(lambda: self.sg_model_train.emit())

        self.wx_io_config = io_config if not None else ModelIOConfigurator()

        qcb_types = QComboBox()  # TODO: placeholder for now, but signifies the multiple training algo waiting to
        #                           be implemented
        qcb_types.addItem("Gradient Descent")

        self.qle_iters = QLineEdit()
        self.qle_iters.setValidator(QIntValidator())
        self.qle_iters.setText("100")

        self.qcb_loss = QComboBox()
        for loss_func in LOSS_FUNCTIONS:
            self.qcb_loss.addItem(loss_func)

        self.qle_rate = QLineEdit()
        self.qle_rate.setValidator(QDoubleValidator(0.0000000001, 10.0, 10))
        self.qle_rate.setText("0.01")

        lyt_form = QFormLayout()
        lyt_form.addRow("Training Algorithm:", qcb_types)
        lyt_form.addRow("Iterations:", self.qle_iters)
        lyt_form.addRow("Loss Function:", self.qcb_loss)
        lyt_form.addRow("Learning Rate:", self.qle_rate)

        lyt_left_menu = QVBoxLayout()
        lyt_left_menu.addWidget(self.wl_mdl_name, 1)
        lyt_left_menu.addWidget(qpb_train, 1)
        lyt_left_menu.addLayout(lyt_form, 4)
        lyt_left_menu.addWidget(QLabel("Model I/O configurator"), 1)
        lyt_left_menu.addWidget(self.wx_io_config, 11)
        # lyt_left_menu.addWidget(QLabel("Console I/O"), 1)
        # lyt_left_menu.addWidget(ConsoleIO(), 7)

        self.setLayout(lyt_left_menu)


class TrainingPage(QWidget):
    """
    Execution page is where you are allow to execute the specified model. It has Model I/O configurator and
    in-app console I/O if the model specifies it.
    """

    def __init__(self, fhndl: ProjectFileHandler, models: List[Model], io_configs_train: List[ModelIOConfigurator], model_weights: list, parent=None):
        super().__init__(parent=parent)

        self.fhndl = fhndl
        self.training_sidemenus: List[TrainingSideMenu] = []
        self.models = models
        self.io_configs_train = io_configs_train
        self.model_weights = model_weights

        self.wtw_static_tabs = QTabWidget()

        lyt_main = QHBoxLayout()
        lyt_main.addWidget(self.wtw_static_tabs)

        self.setLayout(lyt_main)

    @Slot()
    def sl_model_list_refresh(self):
        self.wtw_static_tabs.clear()
        self.training_sidemenus.clear()

        for model, io_config in zip(self.models, self.io_configs_train):
            sidemenu = TrainingSideMenu(model.name, io_config=io_config, parent=self)
            sidemenu.sg_model_train.connect(self.sl_model_train)
            sidemenu.wx_io_config.sg_attrs_updated.connect(self.sl_attr_selcs_update)

            wx_model = QWidget()

            lyt_model = QHBoxLayout()
            lyt_model.addWidget(sidemenu, 3)
            lyt_model.addWidget(model.get_static_view(parent=wx_model), 7)

            wx_model.setLayout(lyt_model)

            self.training_sidemenus.append(sidemenu)
            self.io_configs_train.append(sidemenu.wx_io_config)
            self.model_weights.append(None)
            self.wtw_static_tabs.addTab(wx_model, model.name)

    @Slot()
    def sl_attr_selcs_update(self):
        input_names = self.training_sidemenus[self.wtw_static_tabs.currentIndex()].wx_io_config.get_attr_inp_names()
        output_names = self.training_sidemenus[self.wtw_static_tabs.currentIndex()].wx_io_config.get_attr_out_names()

        attr_selc: AttributeSelector
        for attr_selc in self.models[self.wtw_static_tabs.currentIndex()].attr_selcs:
            if attr_selc.type == NodeState.INPUT:
                attr_selc.update_attr_lists(input_names)
            elif attr_selc.type == NodeState.OUTPUT:
                attr_selc.update_attr_lists(output_names)


    @Slot()
    def sl_model_train(self):
        dprint("MODEL TRAIN",
               self.models[self.wtw_static_tabs.currentIndex()].name,
               int(self.training_sidemenus[self.wtw_static_tabs.currentIndex()].qle_iters.text()))

        iof: IOField
        inst = {
            "inp": {iof.attr_name: iof.data
                       for iof in self.training_sidemenus[self.wtw_static_tabs.currentIndex()].wx_io_config.attributes
                       if iof.state == NodeState.INPUT},
            "out": {iof.attr_name: iof.data
                       for iof in self.training_sidemenus[self.wtw_static_tabs.currentIndex()].wx_io_config.attributes
                       if iof.state == NodeState.OUTPUT},
            "predicting?": False,
            # TODO: nonono, we need to somehow train-sensitive file IO out of the model so we can remove this bad
            #   practice--a model must never know whether its being trained or not
        }

        dprint(inst)

        # TODO: write this temp validation somewhere else
        nodes_inp = 0
        nodes_out = 0
        for item in self.models[self.wtw_static_tabs.currentIndex()].items():
            if isinstance(item, FasterNode):
                if item.node_state == NodeState.INPUT:
                    nodes_inp += 1
                elif item.node_state == NodeState.OUTPUT:
                    nodes_out += 1

        dprint(nodes_inp, nodes_out)
        #  TODO: temporary validation to check the model met a specific req for basic ai/ml
        if nodes_inp == nodes_out == 1:
            model_weight = self.fhndl.train_model(
                self.fhndl.get_mdl_id(self.models[self.wtw_static_tabs.currentIndex()].name),
                iters=int(self.training_sidemenus[self.wtw_static_tabs.currentIndex()].qle_iters.text()),
                loss_name=self.training_sidemenus[self.wtw_static_tabs.currentIndex()].qcb_loss.currentText(),
                rate=float(self.training_sidemenus[self.wtw_static_tabs.currentIndex()].qle_rate.text()),
                inst_state=inst)

            self.model_weights[self.wtw_static_tabs.currentIndex()] = model_weight
        else:
            dprint("TRAINING REQUIREMENTS NOT FILLED")

